变量和函数的声明, 会在JS代码编译阶段被放入内存中

简单说: JS代码会执行两次
	首先
		把变量和函数的声明读取到所在作用域的顶部
	然后
		执行剩余的代码

函数声明
	提升整个函数到顶部, 提升优先级比变量高

变量声明
	仅提升声明部分到顶部, 不提升赋值操作
	var
		提升后的默认值为undefined
		赋值前可以使用
	const/let
		提升后的默认值为undefined
			也有人认为不提升, 理由如下
		在声明函数执行之前, 变量处于暂存死区状态
			暂存死区:  作用域中知道这些变量的存在, 但是在声明函数执行之前无法使用

基础
	宿主环境
		JS本身具有少量的基础API, 例如 Math, Date, console 等
		JS运行的环境称为宿主环境, 提供额外的专属API
			Node.js
				提供了服务器相关的功能API
			浏览器
				提供了操作浏览器相关的API
	window对象
		浏览器中具有一个window对象, 其中包含了所有全局的API
	对象
		引用类型
			一个变量中存储对象类型, 实际存储的是对象的地址, 这个地址指向对象实际存储在堆内存中的位置
			对象类型的变量在赋值给其他变量时, 是对象的地址赋值给目标变量
		构造函数
			可以快速构建固定结构对象的函数
			new运算符
				搭配函数使用, 可以隐式完成一些操作, 返回一个新的对象
				隐式操作
					let this = {}
					this.__proto__ = 函数.prototype
					return this
			原型链机制
				对象使用一个属性时, 优先从自身查找.
如果自身没有, 则到其__proto__属性中查找
			原型prototype
				构造函数的prototype属性中, 可以保存对象使用的各种方法
				在构造函数中, 会自动把 原型prototype 赋值给 生成对象的 __proto__ 属性
				优点: 同一个构造函数生成的多个对象, 其 __proto__ 指向的都是 构造函数的 prototype, 实现了对象方法的复用
	数据类型
		number, string, boolean, undefined, null
		对象
		symbol
			为对象属性添加不重复的唯一标识
		bigint
			大整型数字
	var
		全局变量污染
		var在全局区声明变量时, 变量会存储在window中, 污染全局区
	作用域
		全局作用域
			window
				包含全局API
				var在全局声明的变量存储在这里
			script
				利用 let/const  在全局区中声明的变量存储在这里
		函数作用域
			函数体中
				local
		块级作用域
			利用 {}  配合  let / const 关键词, 形成的作用域
				block

函数
	arguments
		一个函数体中的隐藏属性, 其中保存了函数的所有参数
		是一个伪数组类型, 其原型非数组类型, 不具备数组的相关方法
	函数重载
		通过判断函数的参数个数/类型不同, 在函数体中执行不同的逻辑代码
	this
		this指向运行时所在对象
	闭包
		函数声明时, 会保存其所在的词法环境
		详细说明
			函数声明时, 为了保障在后期调用时能够正常执行,  会查看函数体中使用了哪些变量, 然后根据作用域链的就近原则, 找到这些变量所在的作用域,  把他们保存在自己的 scopes 变量中,  这些被保存的作用域中, 属于函数作用域的称为 闭包(closure)
	函数柯里化
		把一个多参数函数 改为单参数函数的方式
		add(11)(22)(33)
			function add(a){
   return function (b){
       return function (c){
           return a+b+c
       }
   }
}

ES5
	ECMAScript 第五个版本,  发布与2009年
	严格模式
		在脚本顶部书写 'use strict'  字符串, 则后续代码都会运行在严格模式下
		变量必须声明后才能使用
			防止变量名书写错误导致错误的全局变量生成, 导致污染
		函数的this如果指向window, 现在变为 undefined
			防止构造函数忘记写new, 导致this指向window造成全局变量污染
		取消静默失败
			以前不报错的失败, 现在会爆红
		取消函数的callee
			arguments 的 callee 属性代表当前函数,  在匿名函数递归的场景中使用较多, 但是消耗资源多
			现在推荐使用 命名函数递归 代替 匿名函数递归
	函数
		bind
			为函数绑定执行所在的对象和相关参数, 返回一个新的函数,  等待后续执行
			场景: 定时器 等延时执行的场景
		call
			立即触发函数, 把函数放在指定对象中执行, 并传入其他参数
			场景: 执行时临时替换函数的this
		apply
			立即触发函数, 把函数放在指定对象中执行, 其他参数用数组传入
			场景: 把函数的参数改为数组方式传入
	数组的高阶函数
		every
			每个元素都符合条件
		some
			至少存在一个符合条件的元素
		map
			映射, 把数组的每个元素进行处理后, 返回值组成新的数组
		filter
			把符合条件的元素过滤出来, 形成新的数组
		forEach
			单纯的数组遍历
		reduce
			合并数组的每个元素, 最终得到一个值
	对象方法
		Object.defineProperty
			修改旧属性, 配置详细设置
				用字面量方式声明的属性, 默认的所有配置都是真
			添加新属性, 配置详细设置
				所有配置默认都是假
			配置:
				writable
					可写
				enumerable
					可遍历
				configurable
					可重新配置
				value
					默认值
				get
					计算属性使用
					读取属性时触发
				set
					赋值监听时使用
					向属性赋值时触发
	
